# coding: utf-8

"""
    Conekta API

    Conekta sdk  # noqa: E501

    The version of the OpenAPI document: 2.1.0
    Contact: engineering@conekta.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist
from conekta.models.checkout_order_template import CheckoutOrderTemplate

class Checkout(BaseModel):
    """
    It is a sub-resource of the Order model that can be stipulated in order to configure its corresponding checkout
    """
    allowed_payment_methods: conlist(StrictStr) = Field(..., description="Those are the payment methods that will be available for the link")
    expires_at: StrictInt = Field(..., description="It is the time when the link will expire. It is expressed in seconds since the Unix epoch. The valid range is from 2 to 365 days (the valid range will be taken from the next day of the creation date at 00:01 hrs) ")
    monthly_installments_enabled: Optional[StrictBool] = Field(None, description="This flag allows you to specify if months without interest will be active.")
    monthly_installments_options: Optional[conlist(StrictInt)] = Field(None, description="This field allows you to specify the number of months without interest.")
    name: StrictStr = Field(..., description="Reason for charge")
    needs_shipping_contact: Optional[StrictBool] = Field(None, description="This flag allows you to fill in the shipping information at checkout.")
    on_demand_enabled: Optional[StrictBool] = Field(None, description="This flag allows you to specify if the link will be on demand.")
    order_template: CheckoutOrderTemplate = Field(...)
    payments_limit_count: Optional[StrictInt] = Field(None, description="It is the number of payments that can be made through the link.")
    recurrent: StrictBool = Field(..., description="false: single use. true: multiple payments")
    type: StrictStr = Field(..., description="It is the type of link that will be created. It must be a valid type.")
    __properties = ["allowed_payment_methods", "expires_at", "monthly_installments_enabled", "monthly_installments_options", "name", "needs_shipping_contact", "on_demand_enabled", "order_template", "payments_limit_count", "recurrent", "type"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Checkout:
        """Create an instance of Checkout from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of order_template
        if self.order_template:
            _dict['order_template'] = self.order_template.to_dict()
        # set to None if on_demand_enabled (nullable) is None
        # and __fields_set__ contains the field
        if self.on_demand_enabled is None and "on_demand_enabled" in self.__fields_set__:
            _dict['on_demand_enabled'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Checkout:
        """Create an instance of Checkout from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Checkout.parse_obj(obj)

        _obj = Checkout.parse_obj({
            "allowed_payment_methods": obj.get("allowed_payment_methods"),
            "expires_at": obj.get("expires_at"),
            "monthly_installments_enabled": obj.get("monthly_installments_enabled"),
            "monthly_installments_options": obj.get("monthly_installments_options"),
            "name": obj.get("name"),
            "needs_shipping_contact": obj.get("needs_shipping_contact"),
            "on_demand_enabled": obj.get("on_demand_enabled"),
            "order_template": CheckoutOrderTemplate.from_dict(obj.get("order_template")) if obj.get("order_template") is not None else None,
            "payments_limit_count": obj.get("payments_limit_count"),
            "recurrent": obj.get("recurrent"),
            "type": obj.get("type")
        })
        return _obj

