?start : full_query
full_query : select_statement unions?

unions : union+
union : UNION (ALL | DISTINCT)? select_statement

select_statement : \
    SELECT DISTINCT? selected_columns \
    FROM selected_table \
    joins? \
    where_clause? \
    group_by_clause? \
    having_clause? \
    order_by_clause? \
    limit_placeholder \
    SEMICOLON?

// we use a placeholder for the limit clause because we need to be able to insert one
// automatically in the case of reconstruction. if we didn't have a placeholder, we'd
// have to examine ever clause child in `select_statement` to try to figure out where
// to insert our new limit. having a placeholder simplifies this greatly.
limit_placeholder : limit_clause?

// serves as a basis for table and column names
// NOTE this is dialect specific
!quoted_identifier : "`" IDENTIFIER "`"
    | "\"" IDENTIFIER "\""
    | "[" IDENTIFIER "]"
unquoted_identifier : IDENTIFIER
IDENTIFIER : /[a-zA-Z_][a-zA-Z0-9_]*/

selected_table : aliased_table | table_name
aliased_table : table_name as table_alias

table_name : quoted_identifier | unquoted_identifier
table_alias : generic_alias

selected_columns : selected_column ("," selected_column)*
// a selected column can be a value, not just a column name. a value encapsulates
// fully qualified column names, and also functions that use column names
selected_column : aliased_column | COUNT_STAR | value | ALL_COLUMNS
aliased_column : (value | COUNT_STAR) as column_alias
// this is a "fully-qualified" column name, meaning it just has a table name prefixing
// it. keep in mind that the table may be an alias.
fq_column : table_name "." column_name
column_name : quoted_identifier | unquoted_identifier
column_alias : generic_alias

// having one generic alias rule makes it easier to check for reserved keywords
generic_alias : quoted_identifier | unquoted_identifier

joins : join+
join : join_type joined_table "on"i join_condition ("and"i join_condition)*
// note we do not allow outer joins. this is because we cannot control
// the rows that are returned by the outer join, and we cannot depend on the
// join conditions to restrict the returned rows.
// https://www.sqlite.org/syntax/join-operator.html
join_type : legal_join | illegal_join
legal_join : INNER_JOIN
illegal_join : CROSS_JOIN | NATURAL_JOIN | OUTER_JOIN | NATURAL_OUTER_JOIN
join_condition : connecting_join_condition | required_comparison
// one side can be any value, but the other side must be a column
connecting_join_condition : fq_column EQUI_JOIN value
joined_table : aliased_table | table_name

group_by_clause : GROUP_BY group_by_column ("," group_by_column)*
group_by_column : value

having_clause : HAVING having_condition
having_condition : value comparison value

order_by_clause : ORDER_BY order_column ("," order_column)*
order_column : (COUNT_STAR | value) SORT_ORDER?
SORT_ORDER : ASC | DESC

limit_clause : LIMIT (((offset ",")? limit) | (limit OFFSET offset))
limit : NUMBER
offset : NUMBER

where_clause : WHERE where_conditions
where_conditions : where_condition (WHERE_TYPE where_condition)*
where_condition : \
    | required_comparison
    | relational_comparison
    | in_comparison
    | between_comparison
    | "(" where_conditions ")"

// a required comparison is a parameterized, equality-based comparison that
// enforces a constraint on the returned rows.
required_comparison.1 : (fq_column | column_alias) "=" placeholder
relational_comparison : value comparison value
comparison : \
    EQ
    | NEQ
    | LT
    | GT
    | LTE
    | GTE
    | NOT? LIKE
    | IS NOT?
    | SOUNDS_LIKE
    | NOT? (REGEXP | RLIKE)
in_comparison : value NOT? IN in_list
in_list : "(" value ("," value)* ")"
between_comparison : value NOT? BETWEEN value AND value

// for everywhere but the SELECT clause, because that's where column aliases
// are declared, so we cannot use this there
?value : NUMBER
    | string
    | boolean
    | NULL
    | NUMBER_PREFIX? value_expr
    | NUMBER_PREFIX? fq_column
    | NUMBER_PREFIX? placeholder
    | NUMBER_PREFIX? column_alias
    | NUMBER_PREFIX? wrapped_value
wrapped_value : LPAREN value RPAREN
?value_expr : function | arith_expr
?arith_expr : value ARITH_OP value (ARITH_OP value)*

// a function with any number of arguments
function : function_name "(" \
        AGG_FN_MODIFIER? (value ("," value)*)? \
    ")"
function_name : /[a-zA-Z_]+/

?boolean : TRUE | FALSE
?string : ESCAPED_STRING

// a placeholder for a value passed in as a parameter at query execution time
// https://docs.python.org/2/library/sqlite3.html#sqlite3.Cursor.execute
placeholder: ":" IDENTIFIER


SELECT : "select"i
FROM : "from"i
DISTINCT : "distinct"i
ALL : "all"i
UNION : "union"i
SEMICOLON : ";"
ALL_COLUMNS : "*"
WHERE : "where"i
WHERE_TYPE : AND | OR
ORDER_BY : "order"i WS "by"i
LIMIT : "limit"i
OFFSET : "offset"i
GROUP_BY : "group"i WS "by"i
HAVING : "having"i

// this is the only way that a query can have a "*" column spec, because it
// doesn't reveal any information that would be restricted.
COUNT_STAR : "count"i "(" AGG_FN_MODIFIER? ("*" | "1") ")"
AGG_FN_MODIFIER : DISTINCT | ALL

INNER_JOIN : ("inner"i WS)? "join"i
CROSS_JOIN : "cross"i WS "join"i
NATURAL_JOIN : "natural"i WS (("left"i | "right"i | "full"i | "inner"i) WS)? "join"i
OUTER_JOIN : ("left"i | "right"i | "full"i) WS ("outer"i WS)? "join"i
NATURAL_OUTER_JOIN : "natural"i WS (("left"i | "right"i | "full"i) WS)? "outer"i WS "join"i

ASC : "asc"i
DESC : "desc"i

AND : "and"i
OR : "or"i

// a rule instead of a terminal, so it can be present or not in the input, but the
// tree will always contain a placeholder for it, making tree validation easier than
// if it was sometimes there and sometimes not
as : "as"i?

// important! only allow an equi join, so we can carefully control the rows
// that the user has access to
EQUI_JOIN : "="

EQ : "="
NEQ : "!="
LT : "<"
GT : ">"
LTE : "<="
GTE : ">="
IS : "is"i
BETWEEN : "between"i
IN : "in"i
SOUNDS_LIKE : "sounds"i WS "like"i
LIKE : "like"i
NOT : "not"i
REGEXP : "regexp"i
RLIKE : "rlike"i

TRUE : "true"i
FALSE : "false"i
NULL : "null"i

LPAREN : "("
RPAREN : ")"

NUMBER_PREFIX : "+" | "-" | "~"
ARITH_OP : \
    "+"
    | "-"
    | "*"
    | "/"
    | "%"
    | "^"
    | "<<"
    | ">>"
    | "&"
    | "|"
    | "div"i
    | "mod"i

// in sqlite, double quotes are used for quoting identifiers, single quotes for quoting
// strings. also, a single quote can be escaped by doubling it, and there are no other
// escape sequences. https://www.sqlite.org/faq.html#q14 the below inner regex says "any
// character except a single quote, unless it is doubled"
ESCAPED_STRING : "'" /([^']|'')*/ "'"

%import common.NUMBER
%import common.DIGIT
%import common.WORD
%import common.WS
%ignore WS