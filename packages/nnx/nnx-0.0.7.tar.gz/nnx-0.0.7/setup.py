# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['nnx', 'nnx.nn']

package_data = \
{'': ['*']}

install_requires = \
['jax', 'jaxlib', 'optax', 'typing-extensions']

setup_kwargs = {
    'name': 'nnx',
    'version': '0.0.7',
    'description': '',
    'long_description': '[![codecov](https://codecov.io/gh/cgarciae/nnx/branch/main/graph/badge.svg?token=VqJjL474Z7)](https://codecov.io/gh/cgarciae/nnx)\n\n# NNX\n\n_**N**eural **N**etworks for JA**X**_\n\nNNX is a Neural Networks library for JAX that provides a simple yet powerful module system that adheres to standard Python semantics. Its aim is to combine the robustness of [Flax](https://flax.readthedocs.io/en/latest/) with a simplified, Pythonic API akin to that of [PyTorch](https://pytorch.org/).\n\n* **Pythonic**: Modules are just regular python classes, they contain their own state, are fully mutable, and allow sharing references between Modules.\n* **Compatible**: Easily convert back and forth between Modules and pytrees using the Functional API to integrate with any JAX API.\n* **Safe**: NNX incorporates mechanisms to try to prevent tracer leakage, avoid stale RNGs, and ensure proper state propagation in order to help produce correct JAX programs.\n* **Semantic**: Partition a Module\'s state into different semantic collections, allowing for fine-grained control when applying JAX transformations.\n\n#### Table of Contents\n* [Installation](#installation)\n* [Getting Started](#getting-started)\n* [FAQs](#faqs)\n* [Examples](#examples)\n* [User Guide](#user-guide)\n\n## Installation\n\nTo get started with `nnx`, install the package via pip:\n\n```\npip install nnx\n```\nFor the most recent version, install directly from our GitHub repository:\n\n```\npip install git+https://github.com/cgarciae/nnx\n```\n\n## Getting Started\n\nThe following example guides you through creating a basic `Linear` model with NNX and executing a forward pass. It also demonstrate how handle mutable state by showing how to keep track of the number of times the model has been called.\n\n```python\nimport nnx\nimport jax\nimport jax.numpy as jnp\n\nclass Count(nnx.Variable): pass\n\nclass Linear(nnx.Module):\n    def __init__(self, din: int, dout: int, *, ctx: nnx.Context):\n        key = ctx.make_rng("params")\n        self.w = nnx.Param(jax.random.uniform(key, (din, dout)))\n        self.b = nnx.Param(jnp.zeros((dout,)))\n        self.count = Count(0)  # track the number of calls\n\n    def __call__(self, x):\n        self.count += 1\n        return x @ self.w + self.b\n\nmodel = Linear(din=12, dout=2, ctx=nnx.context(0))\n\n# Forward pass and verify the call count\nx = jnp.ones((8, 12))\ny = model(x)\nassert model.count == 1\n```\n\nIn this example `nnx.context(0)` create a `PRNGKey` for `params` with seed `0`, this is used by `make_rng`\ninside `__init__` to generate a random key to initialize the parameters.\n\n### Training with the Functional API\n\nThe [Functional API](#functional-api) converts an NNX Module python semantics into pure pytree object with functional semantics. It is the recommended way to use NNX as it provides tight control over the state, allows you to use regular JAX transformations, and it minimizes overhead. In this example the model will be trained using Stochastic Gradient Descent (SGD).\n\n```python\n(params, counts), moduledef = model.partition(nnx.Param, Count)\n\n@jax.jit\ndef train_step(params, counts, x, y):\n    def loss_fn(params):\n        y_pred, (updates, _) = moduledef.apply(params, counts)(x)\n        loss = jax.numpy.mean((y_pred - y) ** 2)\n        return loss, updates.filter(Count)\n\n    # compute gradient\n    grads, counts = jax.grad(loss_fn, has_aux=True)(params)\n    # SGD update\n    params = jax.tree_map(lambda w, g: w - 0.1 * g, params, grads)\n\n    return params, counts\n\n# execute the training step\nparams, counts = train_step(params, counts, x, y)\nmodel = moduledef.merge(params, counts)\nassert model.count == 2\n```\n\n### Training with Lifted Transforms\n\n[Lifted Transforms](#lifted-transforms) provide a convenient way interact with NNX Modules. In this example, we use the `nnx.jit` and `nnx.grad` lifted transforms to define the training step. The model is trained using Stochastic Gradient Descent (SGD). Because lifted transforms automatically update the Module\'s state, `train_step` doesn\'t require a return statement.\n\n```python\n@nnx.jit\ndef train_step(model, x, y):\n    def loss_fn(model):\n        y_pred = model(x)\n        return jax.numpy.mean((y_pred - y) ** 2)\n    \n    # compute gradient\n    grads: nnx.State = nnx.grad(loss_fn, wrt=nnx.Param)(model)\n    # SGD update\n    model.update_state(\n        jax.tree_map(lambda w, g: w - 0.1 * g, model.filter(nnx.Param), grads)\n    )\n\n# execute the training step\ntrain_step(model, x, y)\nassert model.count == 2\n```\n\n**Note**: Using `nnx.jit` introduces some overhead when compared to using `jax.jit` directly. Use `nnx.jit` for simple prototypes, but for production code use `jax.jit` directly.\n\n## Examples\n\n* [Using the Functional API](https://github.com/cgarciae/nnx/blob/main/examples/01_functional_api.py): Shows how to train a simple model using the functional API.\n* [Using Lifted Transforms](https://github.com/cgarciae/nnx/blob/main/examples/02_lifted_transforms.py): Shows how to train a simple model using lifted transforms.\n* [Using TrainState](https://github.com/cgarciae/nnx/blob/main/examples/03_train_state.py): Shows how to train a simple model using the functional API with the help of `TrainState`.\n* [Using PureModule](https://github.com/cgarciae/nnx/blob/main/examples/04_pure.py) (experimental): Shows how to train a simple model using the functional API and leveraging `PureModule` to simplify the code.\n* [Training a VAE](https://github.com/cgarciae/nnx/blob/main/examples/05_vae.py): Shows how to train a VAE on the binarized MNIST dataset, uses the functional API, `TrainState`, and shows how to use capture intermediate values to retrieve `kl_loss`.\n* [Scan over layers](https://github.com/cgarciae/nnx/blob/main/examples/06_scan_over_layers.py): An contrived example that implements scan over layers with dropout and a share BatcNorm layer to showcase how lifted transforms can be implemented. It uses the functional API along with `jax.vmap` and `jax.lax.scan`.\n* [Creating a Transformer](https://github.com/cgarciae/nnx/blob/main/examples/07_transformer.py): Shows how to create a Transformer with an auto-regressive decoder that uses scan over layers and a kv-cache for fast inference. Credits to @levskaya.\n\n## FAQs\n\n### Status\nNNX is still in early development so expect bugs and breaking changes. That said, current API is the result of months of experimentation and we don\'t expect any major changes in the near future.\n\n### How is it different from Flax?\nNNX takes the best features that allow Flax to scale to large projects and integrates them into a much simpler Module system with pythonic semantics. \n\nOne place in which NNX strongly deviates from Flax is that (currently) it avoids shape inference in favor of static initialization. It is not a technical limitation but rather a design choice. This design both simplifies the internal implementation and makes it easier to reason about the code for the user, at the cost of being more verbose at times. On the other hand, Pytorch users will feel right at home.\n\n### How is it different from Equinox?\nWhile they might look similar at a surface-level, NNX\'s Module system is more powerful and flexible than Equinox\'s, it contains the following additional features:\n\n* Uses regular python classes (no mandatory dataclass behavior).\n* Modules are mutable\n* Reference sharing between Modules is allowed\n* Mutable state lives inside the Module (no need for a separate [State container](https://docs.kidger.site/equinox/examples/stateful/)).\n* Supports node metadata and semantic partitioning.\n\nOne major difference between the two frameworks is that, by design, NNX Modules are not Pytrees. This adds a safety layer as it prevents state updates from being lost by accident due to referential transparency. It also removes the need of threading a separate [State container](https://docs.kidger.site/equinox/examples/stateful/) throughout the code in order to propagate state. In NNX state updates are either always preserved or explicitly discarded by the user.\n\n## User Guide\n\n### Modules\n\nNNX Modules are normal python classes, they obey regular python semantics such as mutability and reference sharing, including reference cycles. They can contain 2 types of attributes: node attributes and static attributes. Node attributes include NNX `Variable`s (e.g. `nnx.Param`), Numpy arrays, JAX arrays, submodules Modules, and other NNX types. All other types are treated as static attributes.\n\n```python\nclass Foo(nnx.Module):\n    def __init__(self, ctx: nnx.Context):\n        # node attributes\n        self.variable = nnx.Param(jnp.array(1))\n        self.np_buffer = np.array(2)\n        self.jax_buffer = jnp.array(3)\n        self.node = nnx.Node([4, 5])\n        self.submodule = nnx.Linear(2, 4, ctx=ctx)\n        # static attributes\n        self.int = 1\n        self.float = 2.0\n        self.str = "hello"\n        self.list = [1, 2, 3]\n\nmodel = Foo(din=12, dout=2, ctx=nnx.context(0))\n```\nAs shown above, python container types such as `list`, `tuple`, and `dict` are treated as static attributes, if similar functionality is needed, NNX provides the `Sequence` and `Dict` Modules.\n\n### Functional API\n\nNNX Modules are not pytrees so they cannot be passed to JAX transformations. In order to interact with JAX, a Module must be partitioned into a `State` and `ModuleDef` objects. The `State` object is a flat dictionary-like pytree structure that contains all the deduplicated node attributes, and the `ModuleDef` contains the static attributes and structural information needed to reconstruct the Module.\n\n```python\nstate, moduledef = model.partition()\n```\n```\nState({\n  (\'jax_buffer\',): Array(3),\n  (\'node\',): Node(value=[4, 5]),\n  (\'np_buffer\',): array(2),\n  (\'submodule\', \'bias\'): Param(value=Array(...)),\n  (\'submodule\', \'kernel\'): Param(value=Array(...)),\n  (\'variable\',): Param(value=Array(1))\n})\n```\n\n`State` and `ModuleDef` are pytrees so they can be passed to JAX transformations. More over, `ModuleDef` provides 2 very important methods: `merge` and `apply`. The `merge` method can be used to create a new `Module` from a `State` object:\n\n```python\nmodel = moduledef.merge(state)\n```\nThis can be use to e.g. recreate a module inside a JAX transformation. The `apply` provides a functional interface to the module, it can be used call any method or submodule and get the output and the updated state:\n\n```python\n# run __call__\ny, (state, moduledef) = moduledef.apply(state)(x)\n# run some_method\ny, (state, moduledef) = moduledef.apply(state).some_method(x)\n# run submodule\ny, (state, moduledef) = moduledef.apply(state).submodule(x)\n```\n\n`apply` can call any nested method or submodule as long as it can be accessed via the `.` or `[]` operators.\n\n### Partitioning State\nIn NNX you can filter based on any node type, most commonly you will want to filter based on `nnx.Variable` subclasses such as `nnx.Param` or `nnx.BatchStat`.\n\nHere are various examples of how you can use the `partition` method to split a module into multiple substates:\n\n```python\n# partition the module into the state with all the nodes and the moduledef\nstate, moduledef = model.partition()\n# verify that the state contains only params, else raise an error\nparams, moduledef = model.partition(nnx.Param)\n# split the state into params and batch_stats, verify no nodes are left\n(params, batch_stats), moduledef = model.partition(nnx.Param, nnx.BatchStat)\n# if there are any nodes left, use the `...` filter to capture them\n(params, batch_stats, rest), moduledef = model.partition(nnx.Param, nnx.BatchStat, ...)\n# using `...` as the only filter is equivalent to not passing any filters\nmodel.partition(...) = model.partition()\n```\n`partition` will make sure all nodes are match by atleast one filter, else it will raise an error. If you have non-`Variable` nodes like `nnx.Node`, `jax.Array`, or `numpy.ndarray` attributes, you can use the `...` filter which will match any node. For a more general filter you can pass a predicate function of the form:\n\n```python\n(path: Tuple[str, ...], value: Any) -> bool\n```\n\nTo reconstruct the module from a set of substates, you can use `merge` as usual but passing the substates as additional arguments:\n\n```python\nmodel = moduledef.merge(params, batch_stats, rest)\n```\n\nThe same is true for `apply`.\n\n```python\ny, (state, moduledef) = moduledef.apply(params, batch_stats, rest)(x)\n```\n\n Note that `apply` will return a single `state` object, if you need to re-partition the state you can use `State`\'s own `partition` method:\n\n```python\nparams, batch_stats, rest = state.partition(nnx.Param, nnx.BatchStat, ...)\n```\n\nAlternatively, if you are just interested in a subset of partitions, you can use the `State.filter` method which will not raise an error if some nodes are not matched by any filter:\n\n```python\n# only get params\nparams = state.filter(nnx.Param)\n# get params and batch_stats\nparams, batch_stats = state.filter(nnx.Param, nnx.BatchStat)\n```\n\n### Filters\n\nFilters let you select subsets of nodes based on some criteria. These are use throughout the API in method like `partition`, `filter`, and `pop_state`. There are 4 types of filters:\n\n* `type`: matches all node instances of the given type.\n* `...`: matches all nodes.\n* `(path, any) -> bool`: a predicate function that takes a node path and value and returns a boolean.\n* `Tuple[Filter, ...]`: a tuple of filters, matches all nodes that match any of the filters.\n\nNNX also provides the following custom filters:\n\n* `nnx.Not(filter)`: matches all nodes that do not match the given filter\n* `nnx.buffers`: matches all `numpy.ndarray` and `jax.Array` nodes\n\nHere is an example of how to use `Not` and `buffers`:\n```python\nrest = module.filter(nnx.Not(nnx.Param))\nbuffers = module.filter(nnx.buffers)\n```\n\n\n### Capturing Intermediate Values\nIn NNX you can easily propagate intemediate values by simply assigning them to an attribute at runtime. For convenience, you should assign them to a `Variable` attribute with a `collection` name by using `nnx.var` so you can easily retrieve them later.\n\nHere is an example of how to create a `Linear` module that captures its output into a `Variable` attribute with the `intermediates` collection name:\n\n```python\nclass Linear(nnx.Module):\n    def __init__(self, din: int, dout: int, *, ctx: nnx.Context):\n        key = ctx.make_rng("params")\n        self.w = nnx.Param(jax.random.uniform(key, (din, dout)))\n        self.b = nnx.Param(jnp.zeros((dout,)))\n\n    def __call__(self, x):\n        y = x @ self.w + self.b\n        self.y = nnx.Intermediate(y)\n        return y\n\nmodel = Linear(12, 2, ctx=nnx.context(0))\n```\nSince `y` is only created when the module is called, it is not available upon initialization. However, once you call the module `y` will be created. It is recommended that you use `pop_state` to retrieve temporary collections like `Intermediate`:\n\n```python\ny = model(jnp.ones((8, 12)))\nintermediates = model.pop_state(nnx.Intermediate)\n```\n`pop_state` will return a `State` object with the nodes that match the given filter and remove them from the module\'s attributes.\n\n```\nState({\n  (\'y\',): Intermediate(\n    value=Array(...)\n  )\n})\n```\n\nIf you use the functional API to call the module instead, the `Intermediate` nodes will be present in the output `state`. To retrieve the `intermediates` nodes and optionally separate them from the output `state` you can use `State.partition`:\n\n```python\nstate, moduledef = model.partition()\ny, (state, moduledef) = moduledef.apply(state)(jnp.ones((8, 12)))\n# "pop" the intermediates from the state\nintermediates, state = state.partition("intermediates", ...)\n```\n\nAlternatively, you can use `State.filter` to retrieve the `intermediates` nodes without removing them from the `state`.\n\n\n\n### Lifted Transforms\n\nNNX lifted transforms analogous versions of JAX transforms but they know how to work with Modules. They usually perform the following tasks:\n\n* Handle the Module\'s substates and Context\'s RNG streams according to the transform\'s semantics.\n* Properly propagating state in and out of the transform, including updating the input Module\'s state with updates that happen inside the transform.\n\nHere\'s a diagram illustrating how lifted transformations work:\n\n![lifted-transforms](https://raw.githubusercontent.com/cgarciae/nnx/main/docs/images/stateful-transforms.png)\n\nCurrently NNX provides the `jit`, `grad`, and `scan` lifted transforms.\n\n#### Manual Lifting\n\nIn case you want to use JAX transforms directly you can always use the functional API\nto manually lift your Modules. \n\nHere we will create an example of how to implement an MLP that uses "scan over layers" to efficiently process a sequence of inputs assuming that each layer has the same parameters and input/output dimensions. The first thing we need to do is create a `Block` module that represents a single layer, this block with just contain a `Linear` layer, a `Dropout` layer, and a `GELU` activation function:\n\n```python\nclass Block(nnx.Module):\n    def __init__(self, dim: int, *, ctx: nnx.Context):\n        self.linear = nnx.Linear(dim, dim, ctx=ctx)\n        self.dropout = nnx.Dropout(0.5)\n\n    def __call__(self, x: jax.Array, *, train: bool, ctx: nnx.Context) -> jax.Array:\n        x = self.linear(x)\n        x = self.dropout(x, deterministic=not train, ctx=ctx)\n        x = jax.nn.gelu(x)\n        return x\n```\n\nNow we will define `ScanMLP`. During `__init__`, instead of creating a list of `Block`s, we will use `jax.vmap` to create a single `Block` whose parameters have an addtional `layer` axis. This will allow us to pass the parameters as inputs to scan so it will apply a layer at each step.\n\n```python\nclass ScanMLP(nnx.Module):\n    def __init__(self, dim: int, *, n_layers: int, ctx: nnx.Context):\n        params_key = jax.random.split(ctx.make_rng("params"), n_layers)\n        self.n_layers = n_layers\n        self.layers = jax.vmap(\n            lambda key: Block(dim, ctx=nnx.context(params=key)).partition()\n        )(params_key).merge()\n\n```\nNote that we split the `params` key into `n_layers` keys so each layer has different parameters.\n\nNow we will define `__call__`. Here we need to split the `dropout` key into `n_layers` keys so each layer has a different dropout mask, and `partition` the layers to get their `params`. Both `params` and `dropout_key` will be passed as inputs, `x` will be the carry value. Inside the `scan_fn` we will merge the `params` back into a `Block` module and\napply it to the input `x`, passing the sliced `dropout_key` as part of the `Context`.\n\n\n```python\n    def __call__(self, x: jax.Array, *, train: bool, ctx: nnx.Context) -> jax.Array:\n        dropout_key = jax.random.split(ctx.make_rng("dropout"), self.n_layers)\n        params, moduledef = self.layers.partition(nnx.Param)\n\n        def scan_fn(x: inputs):\n            params, dropout_key = inputs\n            module = moduledef.merge(params)\n            x = module(x, train=train, ctx=nnx.context(dropout=dropout_key))\n            return x, module.filter(nnx.Param)\n\n        x, params = jax.lax.scan(scan_fn, x, (params, dropout_key))\n        self.layers.update_state(params)\n        return x\n```\nFinally we apply `jax.lax.scan`, update the `layers` state with the new `params`, and return the final `x` value.\n\nHere is a simple way to test our `ScanMLP`:\n\n```python\nmodel = ScanMLP(10, n_layers=5, ctx=nnx.context(0))\n\nx = jnp.ones((3, 10))\ny = model(x, train=True, ctx=nnx.context(dropout=1))\n```\n\nFor a more robust implementation with comments take a look at the [Scan over layers](https://github.com/cgarciae/nnx/blob/main/examples/06_scan_over_layers.py) example.\n\n### Case Studies\n#### Shared State\n\nIn NNX, you can create modules that share state between them. This is useful when designing complex neural network architectures, as it allows you to reuse certain layers and reduce the number of learnable parameters.\n\nHere\'s an example of creating a module with shared state:\n\n```python\nclass Block(nnx.Module):\n    def __init__(self, linear: nnx.Linear, *, ctx: nnx.Context):\n        self.linear = linear\n        self.bn = nnx.BatchNorm(2, ctx=ctx)\n\n    def __call__(self, x, *, ctx: nnx.Context):\n        x = self.linear(x)\n        x = self.bn(x, ctx=ctx)\n        x = nnx.relu(x)\n        return x\n\nclass Model(nnx.Module):\n    def __init__(self, *, ctx: nnx.Context):\n        shared = nnx.Linear(2, 2, ctx=ctx)\n        self.block1 = Block(shared, ctx=ctx)\n        self.block2 = Block(shared, ctx=ctx)\n\n    def __call__(self, x, *, ctx: nnx.Context):\n        x = self.block1(x, ctx=ctx)\n        x = self.block2(x, ctx=ctx)\n        return x\n```\n\nIn this example, the `Model` module contains two instances of the `Block` module. Each instance shares the same `nnx.Linear` module. To run the model, you can use the Context `flags` argument to set the `use_running_average` flag for all `BatchNorm` modules.\n\nHere\'s an example of computing the loss for a `Model` instance:\n\n```python\ndef loss_fn(model: Model, x: jax.Array, y: jax.Array):\n    ctx = nnx.context(flags=dict(use_running_average=True))\n    y_pred = model(x, ctx=ctx)\n    return jnp.mean((y - y_pred) ** 2)\n```\n\nIt\'s important to note that the state for the shared `nnx.Linear` module will be kept in sync at all times on both `Block` instances, including during gradient updates.\n',
    'author': 'Cristian Garcia',
    'author_email': 'cgarcia.e88@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9,<3.12',
}


setup(**setup_kwargs)
