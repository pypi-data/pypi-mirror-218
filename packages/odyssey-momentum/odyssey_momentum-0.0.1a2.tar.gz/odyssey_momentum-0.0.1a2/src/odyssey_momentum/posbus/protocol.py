import json
import logging
import typing
import uuid

from odyssey_posbus_client import cmath, compat, go, posbus  # type: ignore

from . import auth

logger = logging.getLogger(__name__)

MsgType: typing.TypeAlias = posbus.MsgType

# TODO: commented out, leaving it for a bit
# to make sure we don't circle back to this (runtime generation of the dataclasses).
#
# class MessageBase:
#    def get_type(self) -> posbus.MsgType:
#        return self.msg_type
#
# def _msg_type_lookup(v: posbus.MsgType):
#    """Runtime generate dataclasses from the gopy generated ones."""
#    class_name = v.name.removeprefix("Type")
#    # workaround gopy issues... since those use not usable.
#    clazz = getattr(posbus, class_name)
#    # props = [name for name, value in vars(v).items() if isinstance(value, property)]
#    fields = [ tuple([n, typing.Any]) for n, v in vars(clazz).items() if isinstance(v, property) ]
#    fields.append(('msg_type', v))
#    return make_dataclass(clazz.__name__, fields, kw_only=True, bases=(MessageBase,))
#
#
## go MsgType (uint) -> generate class wrapping the go stuct.
# _MSG_TYPE_MAP = {k: _msg_type_lookup(k) for k in posbus.MsgType}

# So, until we fix WASM or write custom cgo lib:
# we have an asymmetrical message API :'(
# we receive 'maps' which are a subset of JSON
InMessage: typing.TypeAlias = typing.Mapping[str, typing.Any]

# we send autogenerated classes wrapping go structs
OutMessage: typing.TypeAlias = (
    posbus.HandShake | posbus.TeleportRequest | posbus.MyTransform | posbus.HighFive | posbus.ObjectTransform
)
# posbus.Message,


def encode(msg: OutMessage) -> bytes:
    return bytes(compat.encode(msg))


# def encode_map(type_: posbus.MsgType, InMessage) -> bytes:
#    return compat.encode_map(type_, InMessage)


def decode(bs: bytes) -> tuple[posbus.MsgType, InMessage]:
    result = compat.decode(go.Slice_byte(bs))
    type_ = posbus.MsgType(result.type)
    map_ = json.loads(bytes(result.data))
    return process_msg(type_, map_)


def _umid(u: str):
    return go.Slice_byte(uuid.UUID(u).bytes)


def handshake(auth: auth.Auth) -> posbus.HandShake:
    token = auth["token"]
    user_id = _umid(auth["id"])
    session_id = go.Slice_byte(uuid.uuid4().bytes)
    return compat.new_handshake(token, user_id, session_id)


def teleport_request(world_id: str) -> posbus.TeleportRequest:
    world_uuid = _umid(world_id)
    return compat.new_teleport_request(world_uuid)


def my_transform(pos: tuple[float, float, float], rot: tuple[float, float, float]) -> posbus.MyTransform:
    p = cmath.Vec3()
    p.x, p.y, p.z = [*pos]
    r = cmath.Vec3()
    r.x, r.y, r.z = [*rot]
    msg = posbus.MyTransform()
    msg.position = p
    msg.rotation = r
    return msg


def object_transform(
    oid: uuid.UUID,
    pos: tuple[float, float, float],
    rot: tuple[float, float, float],
    scale: tuple[float, float, float] | None = None,
):
    scale = scale if scale else (1, 1, 1)
    id_ = go.Slice_byte(oid.bytes)
    p = cmath.Vec3()
    p.x, p.y, p.z = [*pos]
    r = cmath.Vec3()
    r.x, r.y, r.z = [*rot]
    s = cmath.Vec3()
    s.x, s.y, s.z = [*scale]
    msg = compat.new_object_transform(id_, p, r, s)
    return msg


def high_five(from_: uuid.UUID, to: uuid.UUID) -> posbus.HighFive:
    sender = go.Slice_byte(from_.bytes)
    receiver = go.Slice_byte(to.bytes)
    msg = ""  # TODO: is this used??
    return compat.new_high_five(sender, receiver, msg)


def _signal() -> posbus.Signal:
    return posbus.Signal(posbus.SignalConnected)


"""
def _process_msg(data: typing.Mapping[compat.Slice_posbus_MsgType, dict]):
    for k,v in data.items():
        #msg_type = k[0]
        #msg_data = dict(v)
        return k, v  # TODO: some python types for this
"""


# def process_msg(msg: posbus.Message):
#    """'Cast' a posbus.Message to its actual message type"""
def process_msg(msg_type: posbus.MsgType, data: InMessage) -> tuple[posbus.MsgType, InMessage]:
    # TODO: convert mapping -> data class (preferably autogenerated)
    # clazz = _MSG_TYPE_MAP[msg_type]
    # instance = clazz(msg_type=msg_type, **data)
    return msg_type, data
